'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = gulpStylelint;

var _postcss = require('postcss');

var _postcss2 = _interopRequireDefault(_postcss);

var _stylelint = require('stylelint');

var _stylelint2 = _interopRequireDefault(_stylelint);

var _gulpUtil = require('gulp-util');

var _gulpUtil2 = _interopRequireDefault(_gulpUtil);

var _through = require('through2');

var _through2 = _interopRequireDefault(_through);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Name of this plugin for reporting purposes.
 * @type {String}
 */
/**
 * Gulp stylelint plugin.
 * @module gulp-stylelint
 */

var pluginName = 'gulp-stylelint';

/**
 * Stylelint results processor.
 * @param  {Object}          [options]           Plugin options.
 * @param  {Object}          [options.stylelint] Stylelint options (omit to use .stylelintrc).
 * @param  {Array<Function>} [options.reporters] List of reporters with sequential execution.
 * @param  {Boolean}         [options.debug]     If set to true, error stack trace will be printed.
 * @return {Stream}                              Object stream usable in Gulp pipes.
 */
function gulpStylelint() {
  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

  var promiseList = [];
  var postcssProcessor = (0, _postcss2.default)([(0, _stylelint2.default)(options.stylelint)]);

  /**
   * Launches processing of a given file and adds it to the promise list.
   *
   * Note that the files are not modified and are pushed
   * back to their pipes to allow usage of other plugins.
   *
   * @param  {File}      file      Piped file.
   * @param  {String}    encoding  File encoding.
   * @param  {Function}  done      Done callback.
   * @return {undefined}           Nothing is returned (done callback is used instead).
   */
  function onFile(file, encoding, done) {

    if (file.isNull()) {
      return done(null, file);
    }

    if (file.isStream()) {
      return done(new _gulpUtil2.default.PluginError(pluginName, 'Streaming not supported'));
    }

    var fileContents = file.contents.toString();
    var promise = postcssProcessor.process(fileContents, { from: file.path });

    promiseList.push(promise);

    done(null, file);
  }

  /**
   * Provides Stylelint results to reporters and awaits their response.
   * @param  {Array<Object>} results List of results in Stylelint format.
   * @return {Promise}               Accumulated result of reporters execution.
   */
  function provideResultsToReporters(results) {

    /**
     * Reducer for sequential execution of reporters.
     * @param  {Promise}  promise  Accumulated promise (initial value in reducer).
     * @param  {Function} reporter Reporter function.
     * @return {Promise}           Reporter execution promise.
     */
    function reporterListReducer(promise, reporter) {
      return promise.then(function () {
        return reporter(results);
      });
    }

    return (options.reporters || []).reduce(reporterListReducer, Promise.resolve());
  }

  /**
   * Resolves promises and provides accumulated report to reporters.
   * @param  {Function}  done Done callback.
   * @return {undefined}      Nothing is returned (done callback is used instead).
   */
  function onStreamEnd(done) {
    var _this = this;

    Promise.all(promiseList).then(provideResultsToReporters).then(function () {
      return done();
    }).catch(function (error) {
      // For some reason we need to wrap `emit` in a try-catch block
      // because it immediately throws the given error and the `done`
      // callback is never called as a result.
      try {
        _this.emit('error', new _gulpUtil2.default.PluginError(pluginName, error, {
          showStack: !!options.debug
        }));
      } catch (e) {
        // ¯\_(シ)_/¯
      }
      done();
    });
  }

  return _through2.default.obj(onFile, onStreamEnd);
}